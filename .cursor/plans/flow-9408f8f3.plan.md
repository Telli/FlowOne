<!-- 9408f8f3-aad6-4a1f-8ca3-1d87fe87bf4b 42259441-d2dd-456f-aeef-3de36d49061c -->
# Test Coverage Implementation Plan

## Current State

- **Backend**: No test files exist (0% coverage)
- **Frontend**: No test files exist (AgentTestDialog.tsx is a component, not a test)
- **Infrastructure**: No test runners, mocks, or CI configured

## Goals

- Backend: >80% coverage on API endpoints, services, and data layer
- Frontend: >70% coverage on critical UI flows (agent creation, sessions, flow persistence)
- E2E: Smoke tests for key user journeys (create agent → test → save flow)
- CI: Automated test runs on PR + pre-commit hooks

## Scope

### Backend (Python + FastAPI)

**Test Framework**: pytest + httpx (FastAPI test client) + pytest-asyncio + pytest-cov

**Coverage Targets**:

1. API Endpoints (backend/api/*)

   - agents.py: POST/GET/PATCH agents
   - sessions.py: POST sessions, WS events, POST messages
   - flows.py: CRUD + versioning
   - templates.py: CRUD
   - nlp.py: command parsing
   - health.py: liveness/readiness
   - voice.py: Daily token issuance

2. Services (backend/services/*)

   - gemini_flash.py: synthesize_agent_card, parse_nlp_command, generate_agent_reply (mock httpx)
   - pipecat_runtime.py: SessionManager, Session event queueing
   - gemini_live.py: start/stop (stub verification)

3. Data Layer (backend/memory/*)

   - store.py: CRUD operations, flow persistence, template seeding

4. Observability (backend/observability/*)

   - langfuse.py: trace_event returns trace_id, fail-open behavior

**Test Structure**:

```
backend/
├─ tests/
│  ├─ conftest.py          # fixtures: test_client, test_db, mock_settings
│  ├─ unit/
│  │  ├─ test_gemini_flash.py
│  │  ├─ test_pipecat_runtime.py
│  │  └─ test_store.py
│  ├─ integration/
│  │  ├─ test_api_agents.py
│  │  ├─ test_api_sessions.py
│  │  ├─ test_api_flows.py
│  │  └─ test_api_templates.py
│  └─ e2e/
│     └─ test_agent_lifecycle.py  # create → session → patch → flow save
```

### Frontend (TypeScript + React)

**Test Framework**: Vitest + React Testing Library + MSW (Mock Service Worker)

**Coverage Targets**:

1. API Client (src/lib/apiClient.ts)

   - All endpoints: createAgent, createSession, nlpCommands, flows, templates, patchAgent
   - Error handling, trace_id extraction

2. UI Components (src/components/*)

   - AgentConfigForm: form submission, backend integration
   - AgentTestDialog: session creation, WS connection, message display
   - AIAssistant: NLP command submission, trace_id display
   - AgentPalette: template fetch, drag behavior
   - FlowCanvas: node/edge operations (ReactFlow integration)

3. State Management (src/App.tsx)

   - createAgent flow
   - modifyAgent with PATCH mapping
   - saveFlow/loadFlow
   - Session event handling

**Test Structure**:

```
src/
├─ tests/
│  ├─ setup.ts              # MSW handlers, test utils
│  ├─ unit/
│  │  ├─ apiClient.test.ts
│  │  └─ aiProcessor.test.ts
│  ├─ integration/
│  │  ├─ AgentConfigForm.test.tsx
│  │  ├─ AgentTestDialog.test.tsx
│  │  ├─ AIAssistant.test.tsx
│  │  └─ App.test.tsx
│  └─ e2e/
│     └─ agent-flow.spec.ts  # Playwright: full user journey
```

### Frontend (voice-studio, interactive-studio)

**Similar structure** for each workspace:

- Unit: component rendering, prop handling
- Integration: backend API mocks (MSW)
- Focus: VoiceConsole (Daily join), TranscriptPanel, PersonaChips

## Implementation Steps

### Phase 1: Backend Unit Tests

1. Add pytest deps to requirements.txt (pytest, pytest-asyncio, pytest-cov, httpx)
2. Create conftest.py with fixtures:

   - `test_db`: in-memory SQLite
   - `test_client`: FastAPI TestClient
   - `mock_settings`: override env vars
   - `mock_httpx`: patch Gemini API calls

3. Write unit tests for services (gemini_flash, store, pipecat_runtime)
4. Write unit tests for observability (langfuse trace_event)

### Phase 2: Backend Integration Tests

1. Test all API endpoints with TestClient
2. Mock external deps (Gemini API, Daily API, Langfuse)
3. Verify request/response schemas, error codes, trace_id presence
4. Test WebSocket /sessions/:id/events flow

### Phase 3: Frontend Unit Tests

1. Add Vitest + RTL to src/package.json
2. Setup MSW handlers for all backend endpoints
3. Test apiClient.ts functions (mock fetch)
4. Test isolated components (AgentConfigForm, AIAssistant)

### Phase 4: Frontend Integration Tests

1. Test full UI flows (create agent → form submit → backend mock response)
2. Test session creation + WS mock
3. Test flow save/load with MSW handlers

### Phase 5: E2E Tests

1. Add Playwright to root package.json
2. Write smoke tests:

   - Create agent via UI → verify backend call
   - Start session → verify WS connection
   - Save/load flow → verify persistence

3. Run against real local backend (not mocked)

### Phase 6: CI/CD

1. Add GitHub Actions workflow (.github/workflows/test.yml):

   - Backend: pytest with coverage report
   - Frontend: vitest run with coverage
   - E2E: playwright test (optional)

2. Add pre-commit hook (husky): run tests before commit
3. Coverage thresholds: fail if <80% (backend), <70% (frontend)

## Acceptance Criteria

- `pytest backend/tests --cov=backend --cov-report=term` shows >80% coverage
- `npm test --workspace=src` shows >70% coverage
- All critical paths tested:
  - Agent CRUD (create, fetch, patch)
  - Session lifecycle (create, WS events, text messages)
  - Flow persistence (save, load, versions)
  - Template management
  - NLP command parsing
  - Health checks
- CI pipeline green on all PRs
- E2E smoke test passes locally

## Non-Goals (defer to future)

- Performance/load testing (k6, locust)
- Visual regression (Percy, Chromatic)
- Contract testing (Pact)
- Mutation testing

## Files to Create/Modify

**Backend**:

- requirements.txt (add pytest, pytest-asyncio, pytest-cov)
- backend/tests/conftest.py
- backend/tests/unit/test_*.py (7 files)
- backend/tests/integration/test_api_*.py (7 files)
- backend/tests/e2e/test_agent_lifecycle.py

**Frontend (src/)**:

- src/package.json (add vitest, @testing-library/react, msw)
- src/vitest.config.ts
- src/tests/setup.ts
- src/tests/unit/apiClient.test.ts
- src/tests/integration/*.test.tsx (4 files)

**Root**:

- package.json (add playwright)
- .github/workflows/test.yml
- playwright.config.ts

## Risks & Mitigations

- **Mock complexity**: Use MSW + httpx mocking; keep fixtures DRY
- **WS testing**: Use TestClient + async queue inspection
- **ReactFlow testing**: Mock @xyflow/react with simple stubs
- **Daily/Gemini mocks**: Stub external APIs; real integration tested manually

## Timeline Estimate

- Phase 1-2 (Backend): ~2-3 days
- Phase 3-4 (Frontend): ~2-3 days
- Phase 5 (E2E): ~1 day
- Phase 6 (CI): ~0.5 day

**Total**: ~1 week for full coverage

### To-dos

- [ ] Update backend requirements with pipecat-ai and ensure deps installed
- [ ] Add @daily-co/daily-js to voice-studio package.json
- [ ] Implement Session/SessionManager in pipecat_runtime.py
- [ ] Implement GeminiLiveClient start/stop in gemini_live.py
- [ ] Replace synthesize_agent_card with real Flash call and fallback
- [ ] Implement /voice/tokens using Daily REST and env keys
- [ ] Ensure sessions POST spawns runtime and emits session.started
- [ ] Seed default agent_fitness_coach on startup or first use
- [ ] Implement Daily join, PTT toggle, remote video in VoiceConsole.tsx
- [ ] Render buffered transcript events in TranscriptPanel.tsx
- [ ] Ensure PersonaChips reflects latest persona event
- [ ] Wire Langfuse trace_event for key runtime events